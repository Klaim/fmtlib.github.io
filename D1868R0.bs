<pre class='metadata'>
Title: 🦄 width: clarifying units of width and precision in std::format
Shortname: D1868
Revision: 0
!Draft Revision: 0
Audience: LEWG, SG16
Status: D
Group: WG21
URL: http://fmtlib.net/D1868R0.html
!Source: <a href="https://github.com/fmtlib/blob/master/source/D1868R0.bs">github.com/fmtlib/blob/master/source/D1868R0.bs</a>
Editor: Victor Zverovich, victor.zverovich@gmail.com
Editor: Zach Laine, whatwasthataddress@gmail.com
No abstract: true
Date: 2019-09-18
Markup Shorthands: markdown yes
</pre>

<p style="text-align: right">
“We demand rigidly defined areas of doubt and uncertainty!” <br>
― Douglas Adams
</p>

Introduction {#intro}
============

A new text formatting facility ([[P0645]]) was adopted into the draft standard
for C++20 in Cologne. Unfortunately it left unspecified units of width and
precision which created an ambiguity for string arguments in variable-width
encodings. This paper proposes fixing this shortcoming and specifying width and
precision in a way that addresses the main use case, is locale-independent by
default, and is consistent with the SG16 long-term direction.

Motivating example {#motivation}
==================

To the best of our knowledge, the main use case for the width and precision
format specifiers is to align text when displayed in a terminal. The motivating
example is a columnar view in a typical command-line interface:

<img width="100%"
     src="https://user-images.githubusercontent.com/576385/65346190-f7c27280-db90-11e9-9d26-769844de1972.png" />

We would like to be able to produce similar output with the C++ 20 formatting
facility using the most natural API, namely dynamic width:

```c++
// Prints names in num_cols columns of col_width width each.
void print_columns(const std::vector<std::string>& names,
                   int num_cols, int col_width) {
  for (size_t i = 0, size = names.size(); i < size; ++i) {
    std::cout << std::format("{0:{1}}", names[i], col_width);
    if (i % num_cols == num_cols - 1 || i == size - 1) std::cout << '\n';
  }
}

std::vector<std::string> names = {
  "Die Allgemeine Erklärung der Menschenrechte",
  "『世界人権宣言』",
  "Universal Declaration of Human Rights",
  "Всеобщая декларация прав человека",
  "世界人权宣言",
  "ΟΙΚΟΥΜΕΝΙΚΗ ΔΙΑΚΗΡΥΞΗ ΓΙΑ ΤΑ ΑΝΘΡΩΠΙΝΑ ΔΙΚΑΙΩΜΑΤΑ"
};

print_columns(names, 2, 60);
```

Desired output:

<img width="100%"
     src="https://user-images.githubusercontent.com/576385/65346834-84216500-db92-11e9-8ecb-84b54920cfcf.png" />

Locale {#locale}
======

One of the major design features of the C++20 formatting facility ([[P0645]]) is
locale independence by default with locale-aware formatting available as an
opt-in via separate format specifiers. This has an important safety property
that the result of `formatted_size` by default does not depend on the global
locale and a buffer allocated with this size can be passed safely to `format_to`
even if the locale has been changed in the meantime, possibly from another
thread. It is desirable to preserve this property for strings for both safety
and consistency reasons.

Another observation is that the terminal's encoding is independent from the
execution encoding. For example, on Windows it's possible to change the
console's code page with `chcp` and `SetConsoleOutputCP` ([[SCOCP]])
independently of the active code page or the global locale. It is also possible
to write Unicode text to a console with `WriteConsoleW` regardless of both the
active code page and the console code page. On macOS and Linux, the terminal's
encoding is determined by the settings of the terminal emulator application and
normally defaults to UTF-8.

Therefore, for the purposes of specifying width, the output of `std::format`
shouldn't dynamically depend on the locale's encoding by default. As with other
argument types, a separate format specifier can be added to opt into
locale-specific behavior for interoperability with legacy applications.

Windows {#windows}
=======

According to the Windows documentation ([[WINI18N]]):

> Most applications written today handle character data primarily as Unicode,
> using the UTF-16 encoding.

and

> New Windows applications should use Unicode to avoid the inconsistencies of
> varied code pages and for ease of localization.

Code pages are used primarily by legacy applications or those communicating with
legacy applications such as older mail servers.

<!--
Moreover, Windows API functions that work with code pages transcode inputs and
call their Unicode counterparts, for example, `WriteConsoleA` transcodes the
text in the passed buffer and calls `WriteConsoleW`. This can result in the loss
of information when using legacy I/O APIs:
-->

Since `std::format` is a completely new API which is not a drop-in replacement
for anything in the standard library today and therefore can only be used in the
new code, we think that it should be consistent with the Windows guidelines and
use Unicode by default on this platform. Additionally it should provide an
opt-in mechanism to communicate with legacy applications.

Precision {#precision}
=========

Precision, when applied to a string argument, specifies how many characters will
be used from the string. It can be used to truncate long strings in the columar
output as in the motivating example shown earlier. Because it works with a
single argument and only for some argument types it is not particularly useful
for truncating output to satisfy storage requirements. `format_to_n` should be
used for the latter instead. The semantics of floating-point precision is
also unrelated to storage.

Since precision and width address the same use case, we think that they should
be measured in the same units.

Proposal {#proposal}
========

To address the main use case, we propose defining width and precision for a
string as the *display width*, i.e. in terms of the number of column positions
needed to display it in a terminal. POSIX defines the `wcswidth` function that
has the required semantics ([[WCSWIDTH]]):

> The `wcswidth()` function shall determine the number of column positions
> required for `n` wide-character codes (or fewer than `n` wide-character codes
> if a null wide-character code is encountered before `n` wide-character codes
> are exhausted) in the string pointed to by `pwcs`.

To satisfy the locale-independence property we propose that for the purposes
of width computation the default should be Unicode on system that support
display of Unicode text in a terminal or implementation-defined otherwise.
In particular this allows using EBCDIC on z/OS and ASCII on resource-constrained
embedded systems that may not want to provide even minimal Unicode handling
capabilities.
On Unicode-capable systems both `char` and `wchar_t` strings should use Unicode
encodings (e.g. UTF-8 and UTF-16 respectively) by default. This will enable
portable code with optional transcoding at the system API boundaries (Unicode
sandwich) and seamless integration with APIs that support Unicode such as
`WriteConsoleW` on Windows without data loss.

For Unicode, the first step in computing width is to break the string into
grapheme clusters because the latter correspond to user-perceived characters
([[UAX29]]). Then the width should be adjusted to account for graphemes that
take two column positions as it is done, for example, in the Unicode
implementation of `wcswidth` by Markus Kuhn ([[MGK25]]). Non-printable
characters such as control characters do not contribute to width and it should
be a user's responsibility to ensure that the input string does not contain
leading combining characters that may compose during concatenation.

Width computation can be done efficiently with a single pass over the input and
optimized for the case of no variable-width characters. It has zero overhead
when no width is specified or when formatting non-string arguments.

We also propose adding a new format specifier in C++23 for computing display
width of a string argument based on the locale's encoding, for example:

```c++
std::locale::global(std::locale("ru_RU.KOI8-R"));
std::string message = std::format("{:6ls}", "\xd4\xc5\xd3\xd4"); // "тест" in KOI8-R
// message == "\xd4\xc5\xd3\xd4  " ("тест  " in KOI8-R)
```

We think that the current proposal is in line with SG16: Unicode Direction
([[P1238]]) goal of "Designing for where we want to be and how to get there"
because it creates a clear path for the future `charN_t` overloads of
`std::format` to have the desired behavior and be consistent with the C++20
formatting facility which currently supports `char` and `wchar_t`. It is based
on an existing API, namely `wcswidth` which is a part of POSIX, and has
counterparts in multiple languages, for example:

* C `wcwidth` ([[MGK25]])
* Go `go-runewidth` ([[RUNEWIDTH]])
* JavaScript `wcwidth.js` ([[WCWIDTH-JS]])
* Julia `Base.UTF8proc.charwidth`, `Base.strwidth` ([[CHARWIDTH]]) - a part of
    the standard library
* Perl: `Text::CharWidth` ([[TCW]])
* Python `wcwidth` ([[WCWIDTH-PY]]) - used by over 60,000 projects according to
    the GitHub dependency graph
* Ruby `unicode-display_width` ([[UDW]]) - used by over 170,000 projects
    according to the GitHub dependency graph

GitHub code search returns over 500,000 results for "wcwidth" and 180,000
results for "wcswidth".

The number of projects providing this facility together with large usage numbers
indicate that it is an imporant use case. All of the above packages work
exclusively with Unicode.

Why not code units? {#nope}
===================

It might seem tempting at first to make width be measured in code units because
it is simple and avoids the encoding question. However, it is not useful in
addressing practical use cases. Also it is an evolutionary deadend because
standardizing code units for `char` and `wchar_t` overloads by default would
create an incentive for doing the same in `charN_t` overloads or introduce a
confusing difference in behavior.
One might argue that if we do the latter it may push users to the `charN_t`
overloads but intentionally designing an inferior API and creating inconvenience
for users for the goal that may never realise seems wrong.
Measuring width in code units in the fmt library was surprising to some users
resulting in bug reports and eventually switching to higher-level units.

Code units are even less adequate for precision, because they can result in
invalid output. For example

```c++
std::string s = std::format("{:.2}", "\x41\xCC\x81");
```

would result in `s` containing `"\x41\xCC"` if precision was measured in code
units which is clearly broken. In Python's `str.format` precision is measured in
code points which prevents this issue.

Limitations {#limitations}
===========

Unlike terminals, GUI editors often use proportional or monospace fonts that
treat some characters such that their width is not an integer multiple of the
other. Therefore width, regardless of how it is defined, is inherently limited
there. However, it can still be useful if the input domain is restricted.
Possible use cases are aligning numbers, ASCII text, or adding code indentation:

```c++
// Prints text prefixed with indent spaces.
void print_indented(int indent, std::string_view text) {
  std::cout << fmt::format("{0:>{1}}{2}\n", "", indent, text);
}
```

<!-- TODO: https://github.com/JuliaLang/julia/issues/3721 -->

Examples {#examples}
========

```c++
#include <format>
#include <iostream>
#include <stdio.h>

struct input {
  const char* text;
  const char* info;
};

int main() {
  input inputs[] = {
    {"Text", "Description"},
    {"-----",
     "------------------------------------------------------------------------"
     "--------------"},
    {"\x41", "U+0041 { LATIN CAPITAL LETTER A }"},
    {"\xd0\xa9", "U+0429 { CYRILLIC CAPITAL LETTER SHCHA }"}, // Щ
    {"\xce\x94", "U+0394 { Greek Capital Letter Delta }"}, // Δ
    {"\xC3\x81", "U+00C1 { LATIN CAPITAL LETTER A WITH ACUTE }"},
    {"\x41\xCC\x81",
     "U+0041 U+0301 { LATIN CAPITAL LETTER A } { COMBINING ACUTE ACCENT }"},
    {"\xc4\xb2", "U+0132 { Latin Capital Ligature Ij }"}, // Ĳ
    {"\xe2\x80\x8b", "U+200B { ZERO WIDTH SPACE }"},
    {"\xe2\x81\xa3", "U+2063 { INVISIBLE SEPARATOR }"},
    {"\xe2\x81\xa4", "U+2064 { INVISIBLE PLUS }"},
    {"\xe7\x95\x8c", "U+754C { CJK Unified Ideograph-754C }"}, // 界
    {"\xe3\x80\x89", "U+3009 { RIGHT-POINTING ANGLE BRACKET }"}, // 〉
    {"\xf0\x9f\xa6\x84", "U+1F921 { UNICORN FACE }"}, // 🦄
    {"\xf0\x9f\x91\xa8\xe2\x80\x8d\xf0\x9f\x91\xa9\xe2\x80\x8d"
     "\xf0\x9f\x91\xa7\xe2\x80\x8d\xf0\x9f\x91\xa6",
     "U+1F468 U+200D U+1F469 U+200D U+1F467 U+200D U+1F466 "
     "{ Family: Man, Woman, Girl, Boy } "} // 👨‍👩‍👧‍👦
  };

  std::cout << "\nstd::format with the current proposal:\n";
  for (auto input: inputs) {
    std::cout << std::format("{:>5} | {}\n", input.text, input.info);
  }

  std::cout << "\nprintf:\n";
  for (auto input: inputs) {
    printf("%5s | %s\n", input.text, input.info);
  }
}
```

Output on macOS Terminal:

TODO

<img width="100%"
     src="https://user-images.githubusercontent.com/576385/65207193-c4bf9800-da45-11e9-9ba9-f1f58a1794da.png" />

Notice that the `printf` output is completely misaligned because width is
measured in code units.

Output on Windows with console codepage set to 65001 (UTF-8) and the active code
page unchanged:

<img width="100%"
     src="https://user-images.githubusercontent.com/576385/65206716-3991d280-da44-11e9-93e2-8510929e2728.png" />

The Windows console doesn't handle combining accents and complex emoji correctly
which is unrelated to the question of width. We implemented a workaround for
this platform although it's not entirely necessary because if the output is
meaningless, alignment won't make it any better. The new Windows Terminal
reportedly handles emoji correctly. Console bugs aside, `printf` has
the same issues on Windows as on macOS.

TODO: show examples from different terminals and systems

Implementation 🕴️{#implementation}
================

The proposal has been implemented in the fmt library and successfully tested
on a variety of platforms.

Wording 🐉 {#wording}
=========

TODO

<pre class=biblio>
{
  "P0645": {
    "title": "Text Formatting",
    "authors": ["Victor Zverovich"],
    "href": "https://wg21.link/p0645"
  },
  "WCSWIDTH": {
    "title": "`wcswidth()`, The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004 Edition",
    "href": "https://pubs.opengroup.org/onlinepubs/009696799/functions/wcswidth.html"
  },
  "MGK25": {
    "title": "An implementation of `wcwidth()` and `wcswidth()` for Unicode",
    "authors": ["Markus Kuhn"],
    "href": "https://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c"
  },
  "WCWIDTH-PY": {
    "title": "wcwidth: Python library that measures the width of unicode strings rendered to a terminal",
    "href": "https://github.com/jquast/wcwidth"
  },
  "WCWIDTH-JS": {
    "title": "wcwidth.js: a javascript porting of C's wcwidth()",
    "href": "https://github.com/mycoboco/wcwidth.js"
  },
  "CHARWIDTH": {
    "title": "Julia Documentation, Strings, Base.UTF8proc.charwidth",
    "href": "https://docs.julialang.org/en/v0.6/stdlib/strings/#Base.UTF8proc.charwidth"
  },
  "RUNEWIDTH": {
    "title": "wcwidth for golang",
    "href": "https://github.com/mattn/go-runewidth"
  },
  "UDW": {
    "title": "unicode-display_width: Monospace Unicode character width in Ruby ",
    "href": "https://github.com/janlelis/unicode-display_width"
  },
  "TCW": {
    "title": "Text::CharWidth - Get number of occupied columns of a string on terminal",
    "href": "https://metacpan.org/pod/Text::CharWidth"
  },
  "UAX29": {
    "title": "Unicode® Standard Annex #29: Unicode Text Segmentation",
    "href": "https://unicode.org/reports/tr29/"
  },
  "P1238": {
    "title": "SG16: Unicode Direction",
    "authors": [
      "Tom Honermann",
      "Corentin Jabot",
      "JeanHeyd Meneide",
      "Mark Zeren",
      "Martinho Fernandes",
      "Peter Bindels",
      "Steve Downey",
      "Zach Laine"
    ],
    "href": "https://wg21.link/p1238"
  },
  "SCOCP": {
    "title": "Console Reference, SetConsoleOutputCP function",
    "href": "https://docs.microsoft.com/en-us/windows/console/setconsoleoutputcp"
  },
  "WINI18N": {
    "title": "Windows documentation, Internationalization for Windows Applications, Code Pages",
    "href": "https://docs.microsoft.com/en-us/windows/win32/intl/code-pages"
  }
}
</pre>
