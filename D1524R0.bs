<pre class='metadata'>
Title: Text Parsing
Shortname: D1524
Revision: 0
Audience: LEWG
Status: D
Group: WG21
URL: http://wg21.link/D1524R0
Editor: Victor Zverovich, viz@fmt.dev
Abstract:
  This paper discusses a new text parsing facility to complement the text
  formatting functionality of [[P0645]].
Date: 2019-05-19
Markup Shorthands: markdown yes
</pre>

Introduction {#introduction}
============

[[P0645]] has proposed a text formatting facility that provides a safe and
extensible alternative to the `printf` family of function. This paper explores
the possibility of adding a symmetric parsing facility which is based on the
same design principles and shares many features with [[P0645]].

According to [[CODESEARCH]], a C and C++ codesearch engine based on the ACTCD19
dataset, there are 389,848 calls to `sprintf` and 87,815 calls to `sscanf` at
the time of writing. So although formatted input functions are less popular than
their output counterparts, they are still widely used.

Lack of a general-purpose parsing facility based on format strings has been
raised in [[P1361]] in the context of formatting and parsing of dates and times.

Although having a symmetric parsing facility seems beneficial, not all languages
provide it out-of-the-box. For example, Python doesn't have a `scanf` equivalent
in the standard library but there is a separate `parse` package ([[PARSE]]).

**Example**:

```c++
std::string key;
int value;
std::scan("answer = 42", "{} = {}", key, value);
//        ~~~~~~~~~~~~~  ~~~~~~~~~  ~~~~~~~~~~
//            input        format   arguments
//
// Result: key == "answer", value == 42
```

TODO: compare with std::chrono::parse in a separate section

Before:

```
std::istringstream is("10:30");
std::chrono::seconds s;
is >> std::chrono::parse("%H:%M", s);
```

After:
```
std::chrono::seconds s;
std::scan("10:30", "{0:%H:%M}", s);
```

Design {#design}
======

The new parsing facility is intended to complement the existing C++ I/O streams
library, integrate well with the chrono library, and provide an API similar to
`std::format`. This section discusses major features of its design.

Format strings {#format-strings}
--------------

As with `printf`, the `scanf` syntax has the advantage of being familiar to many
programmers. However, it has similar limitations:

  * Many format specifiers like `hh`, `h`, `l`, `j`, etc. are used only to
    convey type information. They are redundant in type-safe parsing and would
    unnecessarily complicate specification and parsing.

  * There is no standard way to extend the syntax for user-defined types.

  * Using `'%'` in a custom format specifier poses difficulties, e.g. for
    `get_time`-like time parsing.

Therefore we propose a syntax based on [[PARSE]] and [[P0645]]. This syntax
employs `'{'` and `'}'` as replacement field delimiters instead of `'%'`. It
will provide the following advantages:

  * An easy to parse mini-language focused on the data format rather than
    conveying the type information
  * Extensibility for user-defined types
  * Positional arguments
  * Support for both locale-specific and locale-independent parsing (see
    [[#locales]])
  * Consistency with `std::format` proposed by [[P0645]].

At the same time most of the specifiers will remain the same as in `scanf` which
can simplify, possibly automated, migration.

TODO: formalize syntax, compile-time processing

Safety {#safety}
------

Unlike `scanf`, the proposed parsing facility is fully type safe ... TODO
TODO: illustrate why scanf is unsafe

Extensibility {#extensibility}
-------------

TODO

Locales {#locales}
-------

TODO: control over the use of locales

Positional arguments {#positional-args}
--------------------

TODO

Performance {#performance}
-----------

TODO

Binary footprint {#binary-footprint}
----------------

TODO

Impact on existing code {#deep-impact}
-----------------------

The proposed API is defined in a new header and should have no impact on
existing code. 

Existing work {#existing-work}
=============

TODO: refer to https://github.com/eliaskosunen/scnlib

Questions {#questions}
=========

**Q1**: Do we want this?

**Q2**: API options:

  1. Pass arguments by reference and return an iterator:
     ```
int answer;
auto end = std::scan("42", "{}", answer);
     ```

  2. Return an object with an iterator and parsed values as a tuple:
     ```
auto result = std::scan<int>("42", "{}");
auto end = result.end;
auto answer = std::get<0>(result.values);
     ```

**Q3**: naming:

  1. `scan`
  2. `parse`
  3. other

<pre class=biblio>
{
  "P0645": {
	  "title": "Text Formatting",
	  "authors": ["Victor Zverovich"],
	  "href": "https://wg21.link/p0645"
  },
  "CODESEARCH": {
	  "title": "Code search engine website",
	  "authors": ["Andrew Tomazos"],
	  "href": "https://codesearch.isocpp.org"
  },
  "P1361": {
	  "title": "Integration of chrono with text formatting",
	  "authors": ["Victor Zverovich", "Daniela Engert", "Howard E. Hinnant"],
	  "href": "https://wg21.link/p1361"
  },
  "PARSE": {
	  "title": "Python `parse` package",
	  "href": "https://pypi.org/project/parse/"
  }
}
</pre>