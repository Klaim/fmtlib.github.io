<pre class='metadata'>
Title: Text Parsing
Shortname: D1524
Revision: 0
Audience: LEWG
Status: D
Group: WG21
URL: http://wg21.link/D1524R0
Editor: Victor Zverovich, viz@fmt.dev
Abstract:
  This paper discusses a new text parsing facility to complement the text
  formatting functionality of [[P0645]].
Date: 2019-05-19
Markup Shorthands: markdown yes
</pre>

Introduction {#introduction}
============

[[P0645]] has proposed a text formatting facility that provides a safe and
extensible alternative to the `printf` family of function. This paper explores
the possibility of adding a symmetric parsing facility which is based on the
same design principles and shares many features with [[P0645]], namely

* [[#safety|Safety]]
* [[#extensibility|Extensibility]]
* [[#performance|Performance]]

TODO: list features with links to sections

According to [[CODESEARCH]], a C and C++ codesearch engine based on the ACTCD19
dataset, there are 389,848 calls to `sprintf` and 87,815 calls to `sscanf` at
the time of writing. So although formatted input functions are less popular than
their output counterparts, they are still widely used.

Lack of a general-purpose parsing facility based on format strings has been
raised in [[P1361]] in the context of formatting and parsing of dates and times.

Although having a symmetric parsing facility seems beneficial, not all languages
provide it out-of-the-box. For example, Python doesn't have a `scanf` equivalent
in the standard library but there is a separate `parse` package ([[PARSE]]).

**Example**:

```c++
std::string key;
int value;
std::scan("answer = 42", "{} = {}", key, value);
//        ~~~~~~~~~~~~~  ~~~~~~~~~  ~~~~~~~~~~
//            input        format   arguments
//
// Result: key == "answer", value == 42
```

Design {#design}
======

The new parsing facility is intended to complement the existing C++ I/O streams
library, integrate well with the chrono library, and provide an API similar to
`std::format`. This section discusses major features of its design.

Format strings {#format-strings}
--------------

As with `printf`, the `scanf` syntax has the advantage of being familiar to many
programmers. However, it has similar limitations:

  * Many format specifiers like `hh`, `h`, `l`, `j`, etc. are used only to
    convey type information. They are redundant in type-safe parsing and would
    unnecessarily complicate specification and parsing.

  * There is no standard way to extend the syntax for user-defined types.

  * Using `'%'` in a custom format specifier poses difficulties, e.g. for
    `get_time`-like time parsing.

Therefore we propose a syntax based on [[PARSE]] and [[P0645]]. This syntax
employs `'{'` and `'}'` as replacement field delimiters instead of `'%'`. It
will provide the following advantages:

  * An easy to parse mini-language focused on the data format rather than
    conveying the type information
  * Extensibility for user-defined types
  * Positional arguments
  * Support for both locale-specific and locale-independent parsing (see
    [[#locales]])
  * Consistency with `std::format` proposed by [[P0645]].

At the same time most of the specifiers will remain the same as in `scanf` which
can simplify, possibly automated, migration.

TODO: formalize syntax, compile-time processing

Safety {#safety}
------

`scanf` is arguably more unsafe than `printf` because
`__attribute__((format(scanf, ...)))` ([[ATTR]]) implemented by GCC and Clang
doesn't catch the whole class of buffer overflow bugs, e.g.

```c++
char s[10];
std::sscanf(input, "%s", s); // s may overflow.
```

Specifying the maximum length in the format string above solves the issue but is
error-prone especially since one has to account for the terminating null.

Unlike `scanf`, the proposed facility relies on variadic templates instead of
the mechanism provided by `<cstdarg>`. The type information is captured
automatically and passed to scanners guaranteeing type safety and making many of
the `scanf` specifiers redundant (see [[#format-strings]]). Memory management is
automatic to prevent buffer overflow errors.

Extensibility {#extensibility}
-------------

We propose an extension API for user-defined types similar to the one of
[[P0645]]. It separates format string processing and parsing enabling
compile-time format string checks and allows extending the format specification
language to user types.

The general syntax of a replacement field in a format string is the same as in
[[P0645]]:

```
replacement-field ::= '{' [arg-id] [':' format-spec] '}'
```

where `format-spec` is predefined for built-in types, but can be customized
for user-defined types. For example, the syntax can be extended for
`get_time`-like date and time formatting:

```c++
auto t = tm();
scan(input, "Date: {0:%Y-%m-%d}", t);
```

by providing a specialization of `scanner` for `tm`:

```c++
template <>
struct scanner<tm> {
  constexpr scan_parse_context::iterator parse(scan_parse_context& ctx);

  template <class ScanContext>
  typename ScanContext::iterator scan(tm& t, ScanContext& ctx);
};
```

The `scanner<tm>::parse` function parses the `format-spec` portion of the format
string corresponding to the current argument and `scanner<tm>::scan` parses the
input range `[ctx.begin(), ctx.end())` and stores the result in `t`.

An implementation of `scanner<T>::scan` can potentially use ostream extraction
`operator>>` for user-defined type `T` if available. 

Locales {#locales}
-------

TODO: control over the use of locales

Performance {#performance}
-----------

We can avoid unnecessary copies when parsing string, e.g.

```c++
std::string_view key;
int value;
std::scan("answer = 42", "{} = {}", key, value);
```

This has lifetime implications similar to those of match objects in [[P1433]].

TODO: investigate disallowing temporaries as input and look what ranges do https://en.cppreference.com/w/cpp/ranges/dangling

TODO: add some benchmark

Binary footprint {#binary-footprint}
----------------

TODO

Integration with chrono {#chrono}
-----------------------

TODO: compare with std::chrono::parse in a separate section

Before:

```
std::istringstream is("10:30");
std::chrono::seconds s;
is >> std::chrono::parse("%H:%M", s);
```

After:
```
std::chrono::seconds s;
std::scan("10:30", "{0:%H:%M}", s);
```

Positional arguments {#positional-args}
--------------------

TODO

Impact on existing code {#deep-impact}
-----------------------

The proposed API is defined in a new header and should have no impact on
existing code. 

Existing work {#existing-work}
=============

TODO: refer to https://github.com/eliaskosunen/scnlib

Questions {#questions}
=========

**Q1**: Do we want this?

**Q2**: API options:

  1. Pass arguments by reference and return an iterator:
     ```
int answer;
auto end = std::scan("42", "{}", answer);
     ```

  2. Return an object with an iterator and parsed values as a tuple:
     ```
auto result = std::scan<int>("42", "{}");
auto end = result.end;
auto answer = std::get<0>(result.values);
     ```

**Q3**: naming:

  1. `scan`
  2. `parse`
  3. other

<pre class=biblio>
{
  "P0645": {
	  "title": "Text Formatting",
	  "authors": ["Victor Zverovich"],
	  "href": "https://wg21.link/p0645"
  },
  "CODESEARCH": {
	  "title": "Code search engine website",
	  "authors": ["Andrew Tomazos"],
	  "href": "https://codesearch.isocpp.org"
  },
  "P1361": {
	  "title": "Integration of chrono with text formatting",
	  "authors": ["Victor Zverovich", "Daniela Engert", "Howard E. Hinnant"],
	  "href": "https://wg21.link/p1361"
  },
  "PARSE": {
	  "title": "Python `parse` package",
	  "href": "https://pypi.org/project/parse/"
  },
  "ATTR": {
	  "title": "Common Function Attributes",
	  "href": "https://gcc.gnu.org/onlinedocs/gcc-8.2.0/gcc/Common-Function-Attributes.html"
  },
  "P1433": {
	  "title": "Compile Time Regular Expressions",
	  "authors": ["Hana Dusíková"],
	  "href": "https://wg21.link/p1433"
  }
}
</pre>